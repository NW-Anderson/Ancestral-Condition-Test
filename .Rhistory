if(length(ref.geno) == 32){
geno <- ref.geno
}
par  <- c(cd, #cd1
cd, #cd2
h.vals[i],   #h1
.5,   #h2
1,   #h3
s.vals[1], #sel
.1,  # reduction due to sex geno mismatch
.1,  # r1
.1,  # r2
.1,  # r3
rf,   #rf
.9,  #gs  #no impact good
.5)   #u   #no impact good
# proceeding to the equilibrium for these params
done <- F
while(done == F){
if(length(geno) != 32){stop('1')}
geno <- NewGeno(geno=geno,
par=par,
iter=50,
prnt = F,
tol = 10^-5)[[1]]
# #geno <- NewGeno(geno=geno,
#                 par=par,
#                 iter="stable",
#                 prnt = F,
#                 tol = 10^-5)[[1]]
if(length(geno) != 32){stop('2')}
test.geno <- NewGeno(geno=geno,
par=par,
iter=100,
prnt = F,
tol = 10^-5)[[1]]
if(sum(abs(test.geno - geno)) < 10^(-4)){
done <- T
}
done <- T
geno <- test.geno
cat('hi')
rm(test.geno)
}
rm(done)
# saving eq freqs
premut.eq.geno <- list(geno)
# creating new reference
ref.geno <- geno
if(j == 1){
col.ref.geno <- geno
}
# introduce small r mutation
geno[intro] <- .001
# proceeding to the equilibrium for these params
done <- F
while(done == F){
if(length(geno) != 32){stop('3')}
geno <- NewGeno(geno=geno,
par=par,
iter=50,
prnt = F,
tol = 10^-5)[[1]]
# geno <- NewGeno(geno=geno,
#                 par=par,
#                 iter="stable",
#                 prnt = F,
#                 tol = 10^-5)[[1]]
if(length(geno) != 32){stop('4')}
test.geno <- NewGeno(geno=geno,
par=par,
iter=100,
prnt = F,
tol = 10^-5)[[1]]
if(sum(abs(test.geno - geno)) < 10^(-4)){
done <- T
}
done <- T
geno <- test.geno
cat('bye')
rm(test.geno)
}
rm(done)
# saving eq freqs
postmut.eq.geno <- list(geno)
nullpar  <- c(1, #cd1
1, #cd2
h.vals[i],   #h1
.5,   #h2
1,   #h3
s.vals[1], #sel
.1,  # reduction due to sex geno mismatch
.1,  # r1
.1,  # r2
.1,  # r3
rf,   #rf
.9,  #gs  #no impact good
.5)   #u   #no impact good
param <- param.assign(par)
nullparam <- param.assign(nullpar)
results <- list(sum(geno[seq(2,32,by = 2)]), sum(gen(gen(geno,param), param, return.fit = T)) -
sum(gen(gen(geno,nullparam), nullparam, return.fit = T)), premut.eq.geno,
postmut.eq.geno)
names(results) <- c('freq', 'detload', 'preeq', 'posteq')
results
}
for(k in 1:(length(loop.results)/4)){
result.matrix[i,k] <- as.numeric(loop.results[[1 + 4*(k - 1)]])
devmatrix[i,k] <- as.numeric(loop.results[[2 + 4*(k - 1)]])
premut.eq.array <- cbind(premut.eq.array, loop.results[[3 +  4*(k-1)]])
postmut.eq.array <- cbind(postmut.eq.array, loop.results[[4 +  4*(k-1)]])
}
}
View(result.matrix)
View(postmut.eq.array)
View(premut.eq.array)
install.packages(doMPI)
install.packages("DOBAD")
install.packages("doMPI")
library(doMPI)
setwd("~/GitHub/Ancestral-Condition-Test")
library(R.utils)
library(phytools)
library(diversitree)
library(geiger)
library(doSNOW)
library(foreach)
tree <- read.tree(file = 'Data/whales.tre')
sizes <- read.csv('Data/whale_sizes.csv')
source('AncCond.R')
cl<-makeCluster(3, type="SOCK")
on.exit(stopCluster(cl))
opts <- list(preschedule = FALSE)
registerDoSNOW(cl)
reordered.sizes <- rep(NA, length = length(tree$tip.label))
names(reordered.sizes) <- tree$tip.label
for(i in 1:length(sizes$Australophocaena.dioptrica)){
reordered.sizes[match(gsub( ' ', '_', as.character(sizes$Australophocaena.dioptrica[[i]])),
names(reordered.sizes))] <- sizes$X1.86[[i]]
# if(is.na(match(gsub( ' ', '_', as.character(sizes$Australophocaena.dioptrica[[i]])),
#                 names(reordered.sizes)))){stop(cat('i = ',i))}
}
good.sim <- F
rate <- .1
while(good.sim == F){
disc.trait <- sim.char(phy = tree,
par = matrix(c(-rate, 0, rate, 0), 2),
model = 'discrete',
root = 1)
if(5 < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (length(tree$tip.label) - 5)){
good.sim <- T
}
}
dat <- cbind(tree$tip.label, reordered.sizes, disc.trait)
good.sim <- F
rate <- .1
while(good.sim == F){
disc.trait <- sim.char(phy = tree,
par = matrix(c(-rate, 0, rate, 0), 2),
model = 'discrete',
root = 1)
if(10 < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (length(tree$tip.label) - 10)){
good.sim <- T
}
}
dat <- cbind(tree$tip.label, reordered.sizes, disc.trait)
trees = tree
data = dat
drop.state = 2
mat = c(0,0,1,0)
pi = c(1,0)
## create named vector for disc trait for all extant taxa from input data
dt.vec <- data[, 3]
names(dt.vec) <- data[, 1]
## create named vector for cont trait from input data
## taxa not in derived state optionally not included from drop.state param
if(!is.null(drop.state)){
ct.data <- data[(data[, 3] != drop.state),]
ct.vec <- as.numeric(ct.data[, 2])
names(ct.vec) <- ct.data[, 1]
ct.vec <- ct.vec[!is.na(ct.vec)]
}else{
ct.data <- data
ct.vec <- as.numeric(ct.data[, 2])
names(ct.vec) <- ct.data[, 1]
ct.vec <- ct.vec[!is.na(ct.vec)]
}
## Ancestral state reconstruction for the continuous trait
anc.states.cont.trait <- anc.ML(trees, ct.vec, model = "BM")
## creating the stochastic simulations
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F)=
## Parse simmap to get producing nodes
## the mapped edge object has time spent in a state in
## two columns so only branches with a change have an entry
## in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
## creating the stochastic simulations
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F)=
## Parse simmap to get producing nodes
## the mapped edge object has time spent in a state in
## two columns so only branches with a change have an entry
## in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
total.null <- array(dim = c(1000,10))
total.orig <- c()
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F
)
## Parse simmap to get producing nodes
## the mapped edge object has time spent in a state in
## two columns so only branches with a change have an entry
## in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
# this returns the node pairs describing a branch with origins
wanted_branches <- ss_nodes[ss_nodes == T]
## this returns the node pairs describing a branch with origins
wanted_branches <- ss_nodes[ss_nodes == T]
wanted_nodes <- names(wanted_branches)
## now we take the rootward node of each branch and get rid of duplicates
wanted_nodes <- gsub(",.*", "", wanted_nodes)
producing.nodes <- unique(wanted_nodes)
## get the mean ancestral value for the cont trait
## at nodes producing the derived state marginalizing across trees
anc.states <- anc.states.cont.trait
## Ancestral state reconstruction for the continuous trait
anc.states.cont.trait <- anc.ML(trees, ct.vec, model = "BM")
source('~/GitHub/Ancestral-Condition-Test/AncCondMultiSimmap.R')
# install.packages(c("Rmpi", 'doMPI'))
# library(doMPI)
# library(Rmpi)
library(R.utils)
library(phytools)
library(diversitree)
library(geiger)
library(doSNOW)
library(foreach)
cl<-makeCluster(3, type="SOCK")
on.exit(stopCluster(cl))
opts <- list(preschedule = FALSE)
registerDoSNOW(cl)
n.trees <- 100
n.taxa <- 200
message <- T
# ~50 min
# start <- Sys.time()
# cnt <- 0
# while(T == T){
p.val.vec <- c()
# good.tree <- F
#  cnt <- cnt + 1
#  cat(cnt, '\n\n')
#  while(good.tree == F){
# some trees take a real long time for simulating discrete traits due to incredibly short branch lengths where a transition
#   must occur. To get around this we added a timeout and trycatch. In the event of a tree that is taking an unacceptable time,
#   we begin back here by resimulating a tree
#tryCatch({
# We begin with a single tree and test it at every scaling factor then move to the next tree
# first the tree
trees <- trees(pars = c(3,1),
type = "bd",
n = 1,
max.taxa = n.taxa,
include.extinct = F)[[1]]
trees$edge.length <- trees$edge.length / max(branching.times(trees))
# we then simulate the continious character
cont.trait <- sim.char(trees, 0.2, model = 'BM')
names(cont.trait) <- trees$tip.label # this line somehow makes anc.ML work????
# identifying which branch had a mean cont trait value in the upper and lower quartiles
# we do this by 1st doing an ASR for the continious trait
cont.trait.AC <- anc.ML(trees, cont.trait, model = "BM")
# this will hold all of the branch means in the same order they are given in trees
branch.means <- c()
# branch names is essentially paste(rootward node, tipward node)
branch.names <- c()
# then for each branch we go through and calculate the name and mean
for(j in 1:nrow(trees$edge)){
# we first find the cont trait value at the rootward node
node.o.int <- trees$edge[j,1]
# we have to look in two different places for cont trait values, either in the cont.trait vector
# (if the node is a tip) or in the ASR if it is an interior node
if(node.o.int <= n.taxa){
one <- cont.trait[node.o.int]
}else{
one <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# we do the same for the tipward node
node.o.int <- trees$edge[j,2]
if(node.o.int <= n.taxa){
two <- cont.trait[node.o.int]
}else{
two <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# to find the mean we avg the rootward and the tipward cont trait values
branch.means <- c(branch.means, mean(one, two))
# we create branch names by pasting the rootwward and tipward node labels together
branch.names <- c(branch.names, paste(as.character(trees$edge[j,1]),as.character(trees$edge[j,2])))
}
# we name the branch names for nice bookkeeping
names(branch.means) <- branch.names
rm(branch.names)
# finding upper and lower quartiles
upper <- summary(branch.means)[[5]]
lower <- summary(branch.means)[[2]]
for(s in 1:10){
scale.factor <- s
# we leave the original trees un altered
alt.tree <- trees
# we then manipulate the branch lengths of those branches whose cont trait means are in the upper or lower quartiles
for(j in 1:length(branch.means)){
if(branch.means[j] < lower){alt.tree$edge.length[j] <- alt.tree$edge.length[j] / scale.factor}
if(branch.means[j] > upper){alt.tree$edge.length[j] <- alt.tree$edge.length[j] * scale.factor}
}
# next we simulated a discrete trait on this altered tree
####### Make sure par is set up correctly ######
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
# count <- 0
rate <- .3
#withTimeout({
while(good.sim == F){
disc.trait <- sim.char(phy = alt.tree,
par = matrix(c(-rate, rate, rate, -rate), 2),
model = 'discrete',
root = sample(c(1,2),1))
if((0.05 * n.taxa) < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (.95 * n.taxa)){
good.sim <- T
# if(message == T){cat(min(disc.trait), max(disc.trait), ' good sim ')}
}
# if(message == T && count %% 50 == 0){cat(min(disc.trait),
#                                          max(disc.trait),
#                                          '    ',
#                                          sum(disc.trait == min(disc.trait)),
#                                          '      ')}
# count <- count + 1
}
#}, timeout = 1200, onTimeout = "error")
if(message == T){cat('\n')}
# we now apply the AncCond test to our simulated data and record its result
dat <- cbind(alt.tree$tip.label, cont.trait, disc.trait)
#withTimeout({
rslt <- AncCond(trees = trees,
data = dat,
message = T)# },
# timeout = 1200, onTimeout = "error")
# saving results in arrays
# rslt$`NTrans1->2`
# rslt$`NTrans2->1`
#p.val.array[t,s] <- rslt$pval
p.val.vec[s] <- paste(rslt$`pval1->2`,rslt$`pval2->1`,sep = ',')
if(message == T){cat(' s = ', s)}
}
disc.trait <- sim.char(phy = alt.tree,
par = matrix(c(-rate, rate, rate, -rate), 2),
model = 'discrete',
root = sample(c(1,2),1))
if((0.05 * n.taxa) < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (.95 * n.taxa)){
good.sim <- T
# if(message == T){cat(min(disc.trait), max(disc.trait), ' good sim ')}
}
# if(message == T && count %% 50 == 0){cat(min(disc.trait),
#                                          max(disc.trait),
#                                          '    ',
#                                          sum(disc.trait == min(disc.trait)),
#                                          '      ')}
# count <- count + 1
}
scale.factor <- s
# we leave the original trees un altered
alt.tree <- trees
# we then manipulate the branch lengths of those branches whose cont trait means are in the upper or lower quartiles
for(j in 1:length(branch.means)){
if(branch.means[j] < lower){alt.tree$edge.length[j] <- alt.tree$edge.length[j] / scale.factor}
if(branch.means[j] > upper){alt.tree$edge.length[j] <- alt.tree$edge.length[j] * scale.factor}
}
# next we simulated a discrete trait on this altered tree
####### Make sure par is set up correctly ######
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
# count <- 0
rate <- .3
#withTimeout({
while(good.sim == F){
disc.trait <- sim.char(phy = alt.tree,
par = matrix(c(-rate, rate, rate, -rate), 2),
model = 'discrete',
root = sample(c(1,2),1))
if((0.05 * n.taxa) < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (.95 * n.taxa)){
good.sim <- T
# if(message == T){cat(min(disc.trait), max(disc.trait), ' good sim ')}
}
# if(message == T && count %% 50 == 0){cat(min(disc.trait),
#                                          max(disc.trait),
#                                          '    ',
#                                          sum(disc.trait == min(disc.trait)),
#                                          '      ')}
# count <- count + 1
}
#}, timeout = 1200, onTimeout = "error")
if(message == T){cat('\n')}
# we now apply the AncCond test to our simulated data and record its result
dat <- cbind(alt.tree$tip.label, cont.trait, disc.trait)
data = dat
mc = 1000
drop.state=NULL
mat=c(0,2,1,0)
pi="equal"
## create named vector for disc trait for all extant taxa from input data
dt.vec <- data[, 3]
names(dt.vec) <- data[, 1]
## create named vector for cont trait from input data
## taxa not in derived state optionally not included from drop.state param
if(!is.null(drop.state)){
ct.data <- data[(data[, 3] != drop.state),]
ct.vec <- as.numeric(ct.data[, 2])
names(ct.vec) <- ct.data[, 1]
ct.vec <- ct.vec[!is.na(ct.vec)]
}else{
ct.data <- data
ct.vec <- as.numeric(ct.data[, 2])
names(ct.vec) <- ct.data[, 1]
ct.vec <- ct.vec[!is.na(ct.vec)]
}
## Ancestral state reconstruction for the continuous trait
anc.states.cont.trait <- anc.ML(trees, ct.vec, model = "BM")
## total null will hold all 1000 null data points for each of the 10 stoch simulations in a 1000x 10 array
## null data points are calculated as the mean cont trait value of randomly selected nodes in the ancestral state
## we differentiate between transitions in the 1 -> 2 and 2 -> 1 directions
total.null12 <- array(dim = c(1000,10))
total.null21 <- array(dim = c(1000,10))
## total orig will be a vector of length 10 holding the mean of the cont trait value at the producing nodes
## in each simulation
total.orig12 <- c()
total.orig21 <- c()
## creating the stochastic simulations
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F)=
## Parse simmap to get producing nodes
## the mapped edge object has time spent in a state in
## two columns so only branches with a change have an entry
## in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
## creating the stochastic simulations
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F)=
## Parse simmap to get producing nodes
## the mapped edge object has time spent in a state in
## two columns so only branches with a change have an entry
## in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
## creating the stochastic simulations
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F)=
## Parse simmap to get producing nodes
## the mapped edge object has time spent in a state in
## two columns so only branches with a change have an entry
## in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
## creating the stochastic simulations
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F)
## Parse simmap to get producing nodes
## the mapped edge object has time spent in a state in
## two columns so only branches with a change have an entry
## in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
## this returns the node pairs describing a branch with origins
wanted_branches <- ss_nodes[ss_nodes == T]
wanted_nodes <- names(wanted_branches)
## for this scenario we partition the producing nodes for 1->2 and 1<-2 transitions
producing.nodes12 <- c()
producing.nodes21 <-c()
anc.state.dt$maps[ss_nodes == T]
names(trans.maps[[i]])[1]
trans.maps <- anc.state.dt$maps[ss_nodes == T]
i=1
names(trans.maps[[i]])
source('~/GitHub/Ancestral-Condition-Test/AncCondMultiSimmap.R')
