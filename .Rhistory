pval12 <- NA
}
bigger21 <- (sum(final.null21 >= final.orig21) / mc)
smaller21 <- (sum(final.null21 <= final.orig21) / mc)
if(!is.null(producing.nodes21)){
if (bigger21 <= smaller21){pval21 <- bigger21}
if (smaller21 < bigger21){pval21 <- smaller21}
if (n.tails == 2){pval21 <- 2 * pval21}
}else{
pval21 <- NA
}
## print results to terminal
if (message == T){
cat(paste(
"Mean value for the continuous trait at origin oftrait 2:",
round(orig.val12, digits = 4),
"\n"
))
cat(paste(
"Mean value for the continuous trait at origin of trait 1:",
round(orig.val21, digits = 4),
"\n"
))
cat(paste("Number of producing nodes 1->2:", round(mean(number.of.trans12),
digits = 4), "\n"))
cat(paste("Number of producing nodes 2->1:", round(mean(number.of.trans21),
digits = 4), "\n"))
cat(paste("Mean of null dist 1->2:", round(mean(null.orig.val12),
digits = 4), "\n"))
cat(paste("Mean of null dist 2->1:", round(mean(null.orig.val21),
digits = 4), "\n"))
cat(paste("SD of null dist 1->2:", round(sd(null.orig.val12), digits = 4), "\n"))
cat(paste("SD of null dist 2->1:", round(sd(null.orig.val21), digits = 4), "\n"))
cat(paste("pvalue 1->2:", round(pval12, digits = 4), "\n"))
cat(paste("pvalue 2->1:", round(pval21, digits = 4), "\n\n"))
if(is.null(producing.nodes12)){cat('No 1 -> 2 transitions occured NA and NaN values produced.')}
if(is.null(producing.nodes21)){cat('No 2 -> 1 transitions occured NA and NaN values produced.')}
}
rm.nan
source('~/GitHub/Ancestral-Condition-Test/AncCondMultiSimmap.R')
source('~/GitHub/Ancestral-Condition-Test/AncCondMultiSimmap.R')
cl<-makeCluster(3, type="SOCK")
on.exit(stopCluster(cl))
opts <- list(preschedule = FALSE)
registerDoSNOW(cl)
n.trees <- 100
n.taxa <- 200
message <- T
##### Making fig2 ######
# we do the following for each of 200 trees
# this will hold the p.val for each of 200 tests for the 10 scaling factors
# dont need this for mc
p.val.array <- array(dim = c(n.trees, 10))
p.val.vec <- c()
# good.tree <- F
# while(good.tree == F){
# some trees take a real long time for simulating discrete traits due to incredibly short branch lengths where a transition
#   must occur. To get around this we added a timeout and trycatch. In the event of a tree that is taking an unacceptable time,
#   we begin back here by resimulating a tree
# tryCatch({
# We begin with a single tree and test it at every scaling factor then move to the next tree
# first the tree
trees <- trees(pars = c(3,1),
type = "bd",
n = 1,
max.taxa = n.taxa,
include.extinct = F)[[1]]
trees$edge.length <- trees$edge.length / max(branching.times(trees))
# we then simulate the continious character
cont.trait <- sim.char(trees, 0.2, model = 'BM')
names(cont.trait) <- trees$tip.label # this line somehow makes anc.ML work????
# identifying which branch had a mean cont trait value in the upper and lower quartiles
# we do this by 1st doing an ASR for the continious trait
cont.trait.AC <- anc.ML(trees, cont.trait, model = "BM")
# this will hold all of the branch means in the same order they are given in trees
branch.means <- c()
# branch names is essentially paste(rootward node, tipward node)
branch.names <- c()
# then for each branch we go through and calculate the name and mean
for(j in 1:nrow(trees$edge)){
# we first find the cont trait value at the rootward node
node.o.int <- trees$edge[j,1]
# we have to look in two different places for cont trait values, either in the cont.trait vector
# (if the node is a tip) or in the ASR if it is an interior node
if(node.o.int <= n.taxa){
one <- cont.trait[node.o.int]
}else{
one <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# we do the same for the tipward node
node.o.int <- trees$edge[j,2]
if(node.o.int <= n.taxa){
two <- cont.trait[node.o.int]
}else{
two <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# to find the mean we avg the rootward and the tipward cont trait values
branch.means <- c(branch.means, mean(one, two))
# we create branch names by pasting the rootwward and tipward node labels together
branch.names <- c(branch.names, paste(as.character(trees$edge[j,1]),as.character(trees$edge[j,2])))
}
# we name the branch names for nice bookkeeping
names(branch.means) <- branch.names
rm(branch.names)
# finding upper and lower quartiles
upper <- summary(branch.means)[[5]]
lower <- summary(branch.means)[[2]]
s=10
scale.factor <- s
# we leave the original trees un altered
alt.tree <- trees
# we then manipulate the branch lengths of those branches whose cont trait means are in the upper or lower quartiles
for(j in 1:length(branch.means)){
if(branch.means[j] < lower){alt.tree$edge.length[j] <- alt.tree$edge.length[j] / scale.factor}
if(branch.means[j] > upper){alt.tree$edge.length[j] <- alt.tree$edge.length[j] * scale.factor}
}
# next we simulated a discrete trait on this altered tree
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
# count <- 0
rate <- .1
# withTimeout({
while(good.sim == F){
disc.trait <- sim.char(phy = alt.tree,
par = matrix(c(-rate, 0, rate, 0), 2),
model = 'discrete',
root = 1)
if((0.05 * n.taxa) < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (.95 * n.taxa)){
good.sim <- T
# if(message == T){cat(min(disc.trait), max(disc.trait), ' good sim ')}
}
# if((0.25 * n.taxa) < sum(disc.trait == min(disc.trait)) &&
#    sum(disc.trait == min(disc.trait)) < (0.75 * n.taxa)){
#   good.sim <- T
#   if(message == T){cat(min(disc.trait), max(disc.trait), ' good sim ')}
# }
# if(message == T && count %% 50 == 0){cat(min(disc.trait),
#                                          max(disc.trait),
#                                          '    ',
#                                          sum(disc.trait == min(disc.trait)),
#                                          '      ')}
# count <- count + 1
}# }, timeout = 1200, onTimeout = "error")
if(message == T){cat('\n')}
# we now apply the AncCond test to our simulated data and record its result
dat <- cbind(alt.tree$tip.label, cont.trait, disc.trait)
trees = trees
data = dat
drop.state = 2
mat = c(0,0,1,0)
pi = c(1,0)
mc = 1000
n.tails = 1
## create named vector for disc trait for all taxa
dt.vec <- data[, 3]
names(dt.vec) <- data[, 1]
## create named vector for cont trait taxa not in derived state
if(!is.null(drop.state)){
ct.data <- data[(data[, 3] != drop.state),]
ct.vec <- as.numeric(ct.data[, 2])
names(ct.vec) <- ct.data[, 1]
ct.vec <- ct.vec[!is.na(ct.vec)]
}else{
ct.data <- data
ct.vec <- as.numeric(ct.data[, 2])
names(ct.vec) <- ct.data[, 1]
ct.vec <- ct.vec[!is.na(ct.vec)]
}
## ASR for the continuous trait
anc.states.cont.trait <- anc.ML(trees, ct.vec, model = "BM")
sum(mat == c(0,2,1,0)) == 4
total.null <- array(dim = c(1000,10))
total.orig <- c()
for(nsim in 1:10){
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F
)
## Parse simmap to get producing nodes
# the mapped edge object has time spent in a state in
# two columns so only branches with a change have an entry
# in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
# this returns the node pairs describing a branch with origins
wanted_branches <- ss_nodes[ss_nodes == T]
wanted_nodes <- names(wanted_branches)
# now we take the rootward node of each branch and get rid of duplicates
wanted_nodes <- gsub(",.*", "", wanted_nodes)
producing.nodes <- unique(wanted_nodes)
## get the mean ancestral value for the cont trait
## at nodes producing the derived state marginalizing across trees
anc.states <- anc.states.cont.trait
orig.val <- mean(anc.states$ace[names(anc.states$ace) %in%
producing.nodes])
## Produce the null distribution of nodes in ancestral cond
null.orig.val <- vector(length = mc)
number.of.trans <- length(producing.nodes)
anc.dt <- anc.state.dt
anc.ct <- anc.states.cont.trait
node.states <- describe.simmap(anc.dt)$states
anc.cond.nodes <- anc.ct$ace[names(anc.ct$ace) %in%
names(node.states)[node.states != '2']]
for (j in 1:mc){
# set.seed(j)
null.orig.val[j] <- mean(sample(anc.cond.nodes,
length(producing.nodes)))
}
total.null12[,nsim] <- null.orig.val12
total.null21[,nsim] <- null.orig.val21
total.orig12[nsim] <- orig.val12
total.orig21[nsim] <- orig.val21
}
## ASR for the continuous trait
anc.states.cont.trait <- anc.ML(trees, ct.vec, model = "BM")
library(R.utils)
library(phytools)
library(diversitree)
library(geiger)
library(doSNOW)
library(foreach)
n.trees <- 100
n.taxa <- 200
message <- T
##### Making fig2 ######
# we do the following for each of 200 trees
# this will hold the p.val for each of 200 tests for the 10 scaling factors
# dont need this for mc
p.val.array <- array(dim = c(n.trees, 10))
p.val.vec <- c()
# good.tree <- F
# while(good.tree == F){
# some trees take a real long time for simulating discrete traits due to incredibly short branch lengths where a transition
#   must occur. To get around this we added a timeout and trycatch. In the event of a tree that is taking an unacceptable time,
#   we begin back here by resimulating a tree
# tryCatch({
# We begin with a single tree and test it at every scaling factor then move to the next tree
# first the tree
trees <- trees(pars = c(3,1),
type = "bd",
n = 1,
max.taxa = n.taxa,
include.extinct = F)[[1]]
trees$edge.length <- trees$edge.length / max(branching.times(trees))
# we then simulate the continious character
cont.trait <- sim.char(trees, 0.2, model = 'BM')
names(cont.trait) <- trees$tip.label # this line somehow makes anc.ML work????
# identifying which branch had a mean cont trait value in the upper and lower quartiles
# we do this by 1st doing an ASR for the continious trait
cont.trait.AC <- anc.ML(trees, cont.trait, model = "BM")
# this will hold all of the branch means in the same order they are given in trees
branch.means <- c()
# branch names is essentially paste(rootward node, tipward node)
branch.names <- c()
# then for each branch we go through and calculate the name and mean
for(j in 1:nrow(trees$edge)){
# we first find the cont trait value at the rootward node
node.o.int <- trees$edge[j,1]
# we have to look in two different places for cont trait values, either in the cont.trait vector
# (if the node is a tip) or in the ASR if it is an interior node
if(node.o.int <= n.taxa){
one <- cont.trait[node.o.int]
}else{
one <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# we do the same for the tipward node
node.o.int <- trees$edge[j,2]
if(node.o.int <= n.taxa){
two <- cont.trait[node.o.int]
}else{
two <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# to find the mean we avg the rootward and the tipward cont trait values
branch.means <- c(branch.means, mean(one, two))
# we create branch names by pasting the rootwward and tipward node labels together
branch.names <- c(branch.names, paste(as.character(trees$edge[j,1]),as.character(trees$edge[j,2])))
}
# we name the branch names for nice bookkeeping
names(branch.means) <- branch.names
rm(branch.names)
# finding upper and lower quartiles
upper <- summary(branch.means)[[5]]
lower <- summary(branch.means)[[2]]
s=10
scale.factor <- s
# we leave the original trees un altered
alt.tree <- trees
# we then manipulate the branch lengths of those branches whose cont trait means are in the upper or lower quartiles
for(j in 1:length(branch.means)){
if(branch.means[j] < lower){alt.tree$edge.length[j] <- alt.tree$edge.length[j] / scale.factor}
if(branch.means[j] > upper){alt.tree$edge.length[j] <- alt.tree$edge.length[j] * scale.factor}
}
# next we simulated a discrete trait on this altered tree
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
# count <- 0
rate <- .1
# withTimeout({
while(good.sim == F){
disc.trait <- sim.char(phy = alt.tree,
par = matrix(c(-rate, 0, rate, 0), 2),
model = 'discrete',
root = 1)
if((0.05 * n.taxa) < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (.95 * n.taxa)){
good.sim <- T
# if(message == T){cat(min(disc.trait), max(disc.trait), ' good sim ')}
}
# if((0.25 * n.taxa) < sum(disc.trait == min(disc.trait)) &&
#    sum(disc.trait == min(disc.trait)) < (0.75 * n.taxa)){
#   good.sim <- T
#   if(message == T){cat(min(disc.trait), max(disc.trait), ' good sim ')}
# }
# if(message == T && count %% 50 == 0){cat(min(disc.trait),
#                                          max(disc.trait),
#                                          '    ',
#                                          sum(disc.trait == min(disc.trait)),
#                                          '      ')}
# count <- count + 1
}# }, timeout = 1200, onTimeout = "error")
if(message == T){cat('\n')}
# we now apply the AncCond test to our simulated data and record its result
dat <- cbind(alt.tree$tip.label, cont.trait, disc.trait)
data = dat
drop.state = 2
mat = c(0,0,1,0)
pi = c(1,0)
dt.vec <- data[, 3]
names(dt.vec) <- data[, 1]
## create named vector for cont trait taxa not in derived state
if(!is.null(drop.state)){
ct.data <- data[(data[, 3] != drop.state),]
ct.vec <- as.numeric(ct.data[, 2])
names(ct.vec) <- ct.data[, 1]
ct.vec <- ct.vec[!is.na(ct.vec)]
}else{
ct.data <- data
ct.vec <- as.numeric(ct.data[, 2])
names(ct.vec) <- ct.data[, 1]
ct.vec <- ct.vec[!is.na(ct.vec)]
}
## ASR for the continuous trait
anc.states.cont.trait <- anc.ML(trees, ct.vec, model = "BM")
sum(mat == c(0,2,1,0)) == 4
total.null <- array(dim = c(1000,10))
total.orig <- c()
for(nsim in 1:10){
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F
)
## Parse simmap to get producing nodes
# the mapped edge object has time spent in a state in
# two columns so only branches with a change have an entry
# in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
# this returns the node pairs describing a branch with origins
wanted_branches <- ss_nodes[ss_nodes == T]
wanted_nodes <- names(wanted_branches)
# now we take the rootward node of each branch and get rid of duplicates
wanted_nodes <- gsub(",.*", "", wanted_nodes)
producing.nodes <- unique(wanted_nodes)
## get the mean ancestral value for the cont trait
## at nodes producing the derived state marginalizing across trees
anc.states <- anc.states.cont.trait
orig.val <- mean(anc.states$ace[names(anc.states$ace) %in%
producing.nodes])
## Produce the null distribution of nodes in ancestral cond
null.orig.val <- vector(length = mc)
number.of.trans <- length(producing.nodes)
anc.dt <- anc.state.dt
anc.ct <- anc.states.cont.trait
node.states <- describe.simmap(anc.dt)$states
anc.cond.nodes <- anc.ct$ace[names(anc.ct$ace) %in%
names(node.states)[node.states != '2']]
for (j in 1:mc){
# set.seed(j)
null.orig.val[j] <- mean(sample(anc.cond.nodes,
length(producing.nodes)))
}
total.null12[,nsim] <- null.orig.val12
total.null21[,nsim] <- null.orig.val21
total.orig12[nsim] <- orig.val12
total.orig21[nsim] <- orig.val21
}
mc = 1000
for(nsim in 1:10){
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F
)
## Parse simmap to get producing nodes
# the mapped edge object has time spent in a state in
# two columns so only branches with a change have an entry
# in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
# this returns the node pairs describing a branch with origins
wanted_branches <- ss_nodes[ss_nodes == T]
wanted_nodes <- names(wanted_branches)
# now we take the rootward node of each branch and get rid of duplicates
wanted_nodes <- gsub(",.*", "", wanted_nodes)
producing.nodes <- unique(wanted_nodes)
## get the mean ancestral value for the cont trait
## at nodes producing the derived state marginalizing across trees
anc.states <- anc.states.cont.trait
orig.val <- mean(anc.states$ace[names(anc.states$ace) %in%
producing.nodes])
## Produce the null distribution of nodes in ancestral cond
null.orig.val <- vector(length = mc)
number.of.trans <- length(producing.nodes)
anc.dt <- anc.state.dt
anc.ct <- anc.states.cont.trait
node.states <- describe.simmap(anc.dt)$states
anc.cond.nodes <- anc.ct$ace[names(anc.ct$ace) %in%
names(node.states)[node.states != '2']]
for (j in 1:mc){
# set.seed(j)
null.orig.val[j] <- mean(sample(anc.cond.nodes,
length(producing.nodes)))
}
total.null12[,nsim] <- null.orig.val12
total.null21[,nsim] <- null.orig.val21
total.orig12[nsim] <- orig.val12
total.orig21[nsim] <- orig.val21
}
for(nsim in 1:10){
anc.state.dt <- make.simmap(trees, dt.vec,
model = matrix(mat, 2),
nsim = 1,
pi = pi,
message = F
)
## Parse simmap to get producing nodes
# the mapped edge object has time spent in a state in
# two columns so only branches with a change have an entry
# in both columns
ss_nodes <- anc.state.dt$mapped.edge[, 1] > 0 &
anc.state.dt$mapped.edge[, 2] > 0
# this returns the node pairs describing a branch with origins
wanted_branches <- ss_nodes[ss_nodes == T]
wanted_nodes <- names(wanted_branches)
# now we take the rootward node of each branch and get rid of duplicates
wanted_nodes <- gsub(",.*", "", wanted_nodes)
producing.nodes <- unique(wanted_nodes)
## get the mean ancestral value for the cont trait
## at nodes producing the derived state marginalizing across trees
anc.states <- anc.states.cont.trait
orig.val <- mean(anc.states$ace[names(anc.states$ace) %in%
producing.nodes])
## Produce the null distribution of nodes in ancestral cond
null.orig.val <- vector(length = mc)
number.of.trans <- length(producing.nodes)
anc.dt <- anc.state.dt
anc.ct <- anc.states.cont.trait
node.states <- describe.simmap(anc.dt)$states
anc.cond.nodes <- anc.ct$ace[names(anc.ct$ace) %in%
names(node.states)[node.states != '2']]
for (j in 1:mc){
# set.seed(j)
null.orig.val[j] <- mean(sample(anc.cond.nodes,
length(producing.nodes)))
}
total.null[,nsim] <- null.orig.val
total.orig[nsim] <- orig.val
}
source('~/GitHub/Ancestral-Condition-Test/AncCondMultiSimmap.R')
final.null <- vector(length = 1000)
final.orig <- mean(total.orig)
for(r in 1:1000){
final.null[r] <- mean(total.null[r,])
}
total.null
total.null[1,]
bigger <- (sum(final.null >= final.orig) / mc)
smaller <- (sum(final.null <= final.orig) / mc)
if(!is.null(producing.nodes)){
if (bigger <= smaller){pval <- bigger}
if (smaller < bigger){pval <- smaller}
if (n.tails == 2){pval <- 2 * pval}
}else{
pval <- NA
}
n.tails = 1
if(!is.null(producing.nodes)){
if (bigger <= smaller){pval <- bigger}
if (smaller < bigger){pval <- smaller}
if (n.tails == 2){pval <- 2 * pval}
}else{
pval <- NA
}
## print results to terminal
if(message == T){cat(paste(
"Mean value for the continuous trait at origin of derived trait:",
round(orig.val, digits = 4),
"\n"
))
cat(paste("Number of producing nodes:", round(mean(number.of.trans),
digits = 4), "\n"))
cat(paste("Mean of null dist:", round(mean(null.orig.val),
digits = 4), "\n"))
cat(paste("SD of null dist:", round(sd(null.orig.val), digits = 4), "\n"))
cat(paste("pvalue:", round(pval, digits = 4), "\n\n"))
}
