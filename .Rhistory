#                 prnt = F,
#                 tol = 10^-5)[[1]]
test.geno <- NewGeno(geno=geno,
par=par,
iter=100,
prnt = F,
tol = 10^-5)[[1]]
if(sum(abs(test.geno - geno)) < 10^(-4)){
done <- T
}
done <- T
geno <- test.geno
cat('bye')
rm(test.geno)
}
rm(done)
# saving eq freqs
postmut.eq.geno <- list(geno)
nullpar  <- c(1, #cd1
1, #cd2
h.vals[i],   #h1
.5,   #h2
1,   #h3
s.vals[1], #sel
.1,  # reduction due to sex geno mismatch
.1,  # r1
.1,  # r2
.1,  # r3
rf,   #rf
.9,  #gs  #no impact good
.5)   #u   #no impact good
param <- param.assign(par)
nullparam <- param.assign(nullpar)
results <- list(sum(geno[seq(2,32,by = 2)]), sum(gen(gen(geno,param), param, return.fit = T)) -
sum(gen(gen(geno,nullparam), nullparam, return.fit = T)), premut.eq.geno,
postmut.eq.geno)
result.matrix <- array(dim = c(size,size))
devmatrix <- array(dim = c(size,size))
premut.eq.array <- array()
postmut.eq.array <- array()
for(i in 1:length(h.vals)){
opts <- list(preschedule=FALSE)
loop.results <- foreach(j = 1:length(s.vals), .options.multicore=opts,
.combine = 'cbind') %dopar% {
# for(j in 1:length(s.vals)){
cat('\014')
cat(q,':',(i - 1) * size + j, 'of' , size^2)
cat('\n\n')
# going back to reference (no small r)
# create a new reference for the beginning of each row
if(i == 1){
##### load some initial genotype frequencies; geno #####
ref.geno <- col.ref.geno <- c(.0625,  # XGARs
0.000,  # XGArs
.0625,  # XGaRs
0.000,  # XGars
.0625,  # XgARs
0.000,  # XgArs
.0625,  # XgaRs
0.000,  # Xgars
.0625,  # YGARs
0.000,  # YGArs
.0625,  # YGaRs
0.000,  # YGars
.0625,  # YgARs
0.000,  # YgArs
.0625,  # YgaRs
0.000,  # Ygars
#***** EGG *****#
.125,  # XGARe
0.00,  # XGAre
.125,  # XGaRe
0.00,  # XGare
.125,  # XgARe
0.00,  # XgAre
.125,  # XgaRe
0.00,  # Xgare
0.00,  # YGARe
0.00,  # YGAre
0.00,  # YGaRe
0.00,  # YGare
0.00,  # YgARe
0.00,  # YgAre
0.00,  # YgaRe
0.00)  # Ygare
##### load some initial genotype frequencies #####
} else{
ref.geno <- premut.eq.array[[(i - 2) * size + j]]
}
geno <- ref.geno
par  <- c(cd, #cd1
cd, #cd2
h.vals[i],   #h1
.5,   #h2
1,   #h3
s.vals[1], #sel
.1,  # reduction due to sex geno mismatch
.1,  # r1
.1,  # r2
.1,  # r3
rf,   #rf
.9,  #gs  #no impact good
.5)   #u   #no impact good
# proceeding to the equilibrium for these params
done <- F
while(done == F){
if(length(geno) != 32){stop('1')}
geno <- NewGeno(geno=geno,
par=par,
iter=50,
prnt = F,
tol = 10^-5)[[1]]
# #geno <- NewGeno(geno=geno,
#                 par=par,
#                 iter="stable",
#                 prnt = F,
#                 tol = 10^-5)[[1]]
if(length(geno) != 32){stop('2')}
test.geno <- NewGeno(geno=geno,
par=par,
iter=100,
prnt = F,
tol = 10^-5)[[1]]
if(sum(abs(test.geno - geno)) < 10^(-4)){
done <- T
}
done <- T
geno <- test.geno
cat('hi')
rm(test.geno)
}
rm(done)
# saving eq freqs
premut.eq.geno <- list(geno)
# creating new reference
ref.geno <- geno
if(j == 1){
col.ref.geno <- geno
}
# introduce small r mutation
geno[intro] <- .001
# proceeding to the equilibrium for these params
done <- F
while(done == F){
if(length(geno) != 32){stop('3')}
geno <- NewGeno(geno=geno,
par=par,
iter=50,
prnt = F,
tol = 10^-5)[[1]]
# geno <- NewGeno(geno=geno,
#                 par=par,
#                 iter="stable",
#                 prnt = F,
#                 tol = 10^-5)[[1]]
if(length(geno) != 32){stop('4')}
test.geno <- NewGeno(geno=geno,
par=par,
iter=100,
prnt = F,
tol = 10^-5)[[1]]
if(sum(abs(test.geno - geno)) < 10^(-4)){
done <- T
}
done <- T
geno <- test.geno
cat('bye')
rm(test.geno)
}
rm(done)
# saving eq freqs
postmut.eq.geno <- list(geno)
nullpar  <- c(1, #cd1
1, #cd2
h.vals[i],   #h1
.5,   #h2
1,   #h3
s.vals[1], #sel
.1,  # reduction due to sex geno mismatch
.1,  # r1
.1,  # r2
.1,  # r3
rf,   #rf
.9,  #gs  #no impact good
.5)   #u   #no impact good
param <- param.assign(par)
nullparam <- param.assign(nullpar)
results <- list(sum(geno[seq(2,32,by = 2)]), sum(gen(gen(geno,param), param, return.fit = T)) -
sum(gen(gen(geno,nullparam), nullparam, return.fit = T)), premut.eq.geno,
postmut.eq.geno)
names(results) <- c('freq', 'detload', 'preeq', 'posteq')
results
}
for(k in 1:(length(loop.results)/4)){
result.matrix[i,k] <- as.numeric(loop.results[[1 + 4*(k - 1)]])
devmatrix[i,k] <- as.numeric(loop.results[[2 + 4*(k - 1)]])
premut.eq.array <- cbind(premut.eq.array, loop.results[[3 +  4*(k-1)]])
postmut.eq.array <- cbind(postmut.eq.array, loop.results[[4 +  4*(k-1)]])
}
}
i=j=2
premut.eq.array[[(i - 2) * size + j]]
# dimensions of plot
size <- 2
cd = .95
# reduction in recombination
rfs <-c(.5,1,1)
rf = rfs[q]
# the genotype the mutation is introducted into
intros <- c(10,4,10)
intro <- intros[q]
# these are the parameters varied on the axis. The single point of interest is the single numbers below
h.vals <- seq(0,1,length.out = size)
s.vals <- seq(.1,.6, length.out = size) # seq(0,.5, length.out = size)
# the data stored in this matrix is later plotted. Ending frequency of the recombination modifying mutation
result.matrix <- array(dim = c(size,size))
devmatrix <- array(dim = c(size,size))
premut.eq.array <- array()
postmut.eq.array <- array()
for(i in 1:length(h.vals)){
opts <- list(preschedule=FALSE)
loop.results <- foreach(j = 1:length(s.vals), .options.multicore=opts,
.combine = 'cbind') %dopar% {
# for(j in 1:length(s.vals)){
cat('\014')
cat(q,':',(i - 1) * size + j, 'of' , size^2)
cat('\n\n')
# going back to reference (no small r)
# create a new reference for the beginning of each row
if(i == 1){
##### load some initial genotype frequencies; geno #####
ref.geno <- col.ref.geno <- c(.0625,  # XGARs
0.000,  # XGArs
.0625,  # XGaRs
0.000,  # XGars
.0625,  # XgARs
0.000,  # XgArs
.0625,  # XgaRs
0.000,  # Xgars
.0625,  # YGARs
0.000,  # YGArs
.0625,  # YGaRs
0.000,  # YGars
.0625,  # YgARs
0.000,  # YgArs
.0625,  # YgaRs
0.000,  # Ygars
#***** EGG *****#
.125,  # XGARe
0.00,  # XGAre
.125,  # XGaRe
0.00,  # XGare
.125,  # XgARe
0.00,  # XgAre
.125,  # XgaRe
0.00,  # Xgare
0.00,  # YGARe
0.00,  # YGAre
0.00,  # YGaRe
0.00,  # YGare
0.00,  # YgARe
0.00,  # YgAre
0.00,  # YgaRe
0.00)  # Ygare
##### load some initial genotype frequencies #####
} else{
ref.geno <- premut.eq.array[[(i - 2) * size + j]]
}
if(length(ref.geno) == 32){
geno <- ref.geno
}
par  <- c(cd, #cd1
cd, #cd2
h.vals[i],   #h1
.5,   #h2
1,   #h3
s.vals[1], #sel
.1,  # reduction due to sex geno mismatch
.1,  # r1
.1,  # r2
.1,  # r3
rf,   #rf
.9,  #gs  #no impact good
.5)   #u   #no impact good
# proceeding to the equilibrium for these params
done <- F
while(done == F){
if(length(geno) != 32){stop('1')}
geno <- NewGeno(geno=geno,
par=par,
iter=50,
prnt = F,
tol = 10^-5)[[1]]
# #geno <- NewGeno(geno=geno,
#                 par=par,
#                 iter="stable",
#                 prnt = F,
#                 tol = 10^-5)[[1]]
if(length(geno) != 32){stop('2')}
test.geno <- NewGeno(geno=geno,
par=par,
iter=100,
prnt = F,
tol = 10^-5)[[1]]
if(sum(abs(test.geno - geno)) < 10^(-4)){
done <- T
}
done <- T
geno <- test.geno
cat('hi')
rm(test.geno)
}
rm(done)
# saving eq freqs
premut.eq.geno <- list(geno)
# creating new reference
ref.geno <- geno
if(j == 1){
col.ref.geno <- geno
}
# introduce small r mutation
geno[intro] <- .001
# proceeding to the equilibrium for these params
done <- F
while(done == F){
if(length(geno) != 32){stop('3')}
geno <- NewGeno(geno=geno,
par=par,
iter=50,
prnt = F,
tol = 10^-5)[[1]]
# geno <- NewGeno(geno=geno,
#                 par=par,
#                 iter="stable",
#                 prnt = F,
#                 tol = 10^-5)[[1]]
if(length(geno) != 32){stop('4')}
test.geno <- NewGeno(geno=geno,
par=par,
iter=100,
prnt = F,
tol = 10^-5)[[1]]
if(sum(abs(test.geno - geno)) < 10^(-4)){
done <- T
}
done <- T
geno <- test.geno
cat('bye')
rm(test.geno)
}
rm(done)
# saving eq freqs
postmut.eq.geno <- list(geno)
nullpar  <- c(1, #cd1
1, #cd2
h.vals[i],   #h1
.5,   #h2
1,   #h3
s.vals[1], #sel
.1,  # reduction due to sex geno mismatch
.1,  # r1
.1,  # r2
.1,  # r3
rf,   #rf
.9,  #gs  #no impact good
.5)   #u   #no impact good
param <- param.assign(par)
nullparam <- param.assign(nullpar)
results <- list(sum(geno[seq(2,32,by = 2)]), sum(gen(gen(geno,param), param, return.fit = T)) -
sum(gen(gen(geno,nullparam), nullparam, return.fit = T)), premut.eq.geno,
postmut.eq.geno)
names(results) <- c('freq', 'detload', 'preeq', 'posteq')
results
}
for(k in 1:(length(loop.results)/4)){
result.matrix[i,k] <- as.numeric(loop.results[[1 + 4*(k - 1)]])
devmatrix[i,k] <- as.numeric(loop.results[[2 + 4*(k - 1)]])
premut.eq.array <- cbind(premut.eq.array, loop.results[[3 +  4*(k-1)]])
postmut.eq.array <- cbind(postmut.eq.array, loop.results[[4 +  4*(k-1)]])
}
}
View(result.matrix)
View(postmut.eq.array)
View(premut.eq.array)
install.packages(doMPI)
install.packages("DOBAD")
install.packages("doMPI")
library(doMPI)
setwd("~/GitHub/Ancestral-Condition-Test")
load("~/GitHub/Ancestral-Condition-Test/PagelThreshResults.RData")
pagel.power <- sum(pval.array[,1])
thresh.power <- sum(pval.array[,2])
# install.packages("phytools")
# install.packages("diversitree")
# install.packages("geiger")
# install.packages("coda")
library(coda)
library(R.utils)
library(phytools)
library(diversitree)
library(geiger)
library(doSNOW)
library(foreach)
cl<-makeCluster(3, type="SOCK")
on.exit(stopCluster(cl))
opts <- list(preschedule = FALSE)
registerDoSNOW(cl)
n.trees <- 100
n.taxa <- 200
message <- T
source('AncCond.R', local = TRUE)
pval.array <- p.val.array <- array(dim = c(n.trees, 2))
for(t in 1:n.trees){
trees <- trees(pars = c(3,1),
type = "bd",
n = 1,
max.taxa = n.taxa,
include.extinct = F)[[1]]
trees$edge.length <- trees$edge.length / max(branching.times(trees))
# we then simulate the continious character
cont.trait <- sim.char(trees, 0.2, model = 'BM')
names(cont.trait) <- trees$tip.label # this line somehow makes anc.ML work????
# identifying which branch had a mean cont trait value in the upper and lower quartiles
# we do this by 1st doing an ASR for the continious trait
cont.trait.AC <- anc.ML(trees, cont.trait, model = "BM")
# this will hold all of the branch means in the same order they are given in trees
branch.means <- c()
# branch names is essentially paste(rootward node, tipward node)
branch.names <- c()
# then for each branch we go through and calculate the name and mean
for(j in 1:nrow(trees$edge)){
# we first find the cont trait value at the rootward node
node.o.int <- trees$edge[j,1]
# we have to look in two different places for cont trait values, either in the cont.trait vector
# (if the node is a tip) or in the ASR if it is an interior node
if(node.o.int <= n.taxa){
one <- cont.trait[node.o.int]
}else{
one <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# we do the same for the tipward node
node.o.int <- trees$edge[j,2]
if(node.o.int <= n.taxa){
two <- cont.trait[node.o.int]
}else{
two <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# to find the mean we avg the rootward and the tipward cont trait values
branch.means <- c(branch.means, mean(one, two))
# we create branch names by pasting the rootwward and tipward node labels together
branch.names <- c(branch.names, paste(as.character(trees$edge[j,1]),as.character(trees$edge[j,2])))
}
# we name the branch names for nice bookkeeping
names(branch.means) <- branch.names
rm(branch.names)
# finding upper and lower quartiles
upper <- summary(branch.means)[[5]]
lower <- summary(branch.means)[[2]]
# next we perform the following analysis on this tree for each of the scaling factors
scale.factor <- 1
# we leave the original trees un altered
alt.tree <- trees
# we then manipulate the branch lengths of those branches whose cont trait means are in the upper or lower quartiles
for(j in 1:length(branch.means)){
if(branch.means[j] < lower){alt.tree$edge.length[j] <- alt.tree$edge.length[j] / scale.factor}
if(branch.means[j] > upper){alt.tree$edge.length[j] <- alt.tree$edge.length[j] * scale.factor}
}
# next we simulated a discrete trait on this altered tree
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
rate <- .1
while(good.sim == F){
disc.trait <- sim.char(phy = alt.tree,
par = matrix(c(-rate, 0, rate, 0), 2),
model = 'discrete',
root = 1)
if((0.05 * n.taxa) < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (.95 * n.taxa)){
good.sim <- T
}
}
# creating the discretized cont trait for pagels test
mdn <- summary(cont.trait)[3]
disc.cont.trait <- cont.trait > mdn
disc.cont.trait <- as.character(as.vector(disc.cont.trait) + 1)
disc.trait <- as.vector(as.character(disc.trait))
names(disc.cont.trait) <- names(disc.trait) <- trees$tip.label
# doing pagels test
pagel <- fitPagel(trees, disc.trait, disc.cont.trait, method = 'fitDiscrete')$P
# threshold test
X <- cbind((as.numeric(disc.trait) - 1),as.vector(cont.trait))
colnames(X) <- c('disc.trait', 'cont.trait')
row.names(X) <- trees$tip.label
X <- as.matrix(X)
sample <- 1000 # sample every 1000 steps
ngen <- 50000 # chain length, > 2 million is suggested
burnin <- 0.2 * ngen # 20% of all data is discarded as burnin
thresh <- threshBayes(trees, X, ngen = ngen,
control = list(sample = sample))
thresh1 <- thresh$par[(burnin/sample + 1):nrow(thresh$par), "r"]
class(thresh1) <- 'mcmc'
thresh2 <- HPDinterval(thresh1)
if(sign(thresh2[1,1]) == sign(thresh2[1,2])){thresh3 <- T}
if(sign(thresh2[1,1]) != sign(thresh2[1,2])){thresh3 <- F}
results <- c((pagel < 0.05), thresh3)
results
pval.array[t,] <- results
rm(thresh,thresh1,thresh2,thresh3)
}
pagel.power <- sum(pval.array[,1])
thresh.power <- sum(pval.array[,2])
save(pval.array, file = 'PagelandThreshFPAnalysis.RData')
