count <- 0
rate <- .02
# withTimeout({
while(good.sim == F){
disc.trait <- sim.char(phy = alt.tree,
par = matrix(c(-rate, rate, rate, -rate), 2),
model = 'discrete',
root = 1)
if((0.1 * n.taxa[s]) < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (0.9 * n.taxa[s])){
good.sim <- T
if(message == T){cat(min(disc.trait), max(disc.trait), ' good sim ')}
}
if(message == T && count %% 50 == 0){cat(min(disc.trait),
max(disc.trait),
'    ',
sum(disc.trait == min(disc.trait)),
'      ')}
count <- count + 1
} #}, timeout = 360, onTimeout = "error")
if(message == T){cat('\n')}
# we now apply the AncCond test to our simulated data and record its result
dat <- cbind(alt.tree$tip.label, cont.trait, disc.trait)
# withTimeout({
rslt <- AncCond(trees = trees,
data = dat,
message = F) #},
# timeout = 600, onTimeout = "error")
# saving results in arrays
# p.val.array[t,s] <- rslt$pval
if(message == T){cat('\n')}
# closting the while loop if all goes well
good.tree <- T
# }, error = function(e){good.tree <- F})
}
if(message == T){
cat('\n')
cat(' t = ', t)
}
p.val.vec[t] <- rslt$pval
}
if(message == T){
cat('\n')
cat(' s = ', s)
}
p.val.vec
# end <- sys.time
}
fig5.data <- p.val.array
save(fig5.data, file = 'AncCondFig5Data.RData')
#######
#}
#HPRCAncCondFIG5()
View(fig5.data)
# HPRCAncCondFIG2 <- function(){
# install.packages("phytools")
# install.packages("diversitree")
# install.packages("geiger")
# install.packages(c("Rmpi", 'doMPI'))
# library(doMPI)
# library(Rmpi)
library(R.utils)
library(phytools)
library(diversitree)
library(geiger)
library(doSNOW)
library(foreach)
cl<-makeCluster(3, type="SOCK")
on.exit(stopCluster(cl))
opts <- list(preschedule = FALSE)
registerDoSNOW(cl)
n.trees <- 100
n.taxa <- 200
message <- T
source('AncCond.R', local = TRUE) #### Move inside for HPRC
##### Making fig2 ######
# we do the following for each of 200 trees
# this will hold the p.val for each of 200 tests for the 10 scaling factors
# dont need this for mc
# p.val.array <- array(dim = c(n.trees, 10))
p.val.array <-foreach(t = 1:n.trees, .options.multicore=opts, .combine = 'rbind',
.packages=c("phytools","diversitree","geiger")) %dopar%{
# ~50 min
# start <- Sys.time()
p.val.vec <- c()
good.tree <- F
while(good.tree == F){
# some trees take a real long time for simulating discrete traits due to incredibly short branch lengths where a transition
#   must occur. To get around this we added a timeout and trycatch. In the event of a tree that is taking an unacceptable time,
#   we begin back here by resimulating a tree
# tryCatch({
# We begin with a single tree and test it at every scaling factor then move to the next tree
# first the tree
trees <- trees(pars = c(3,1),
type = "bd",
n = 1,
max.taxa = n.taxa,
include.extinct = F)[[1]]
trees$edge.length <- trees$edge.length / max(branching.times(trees))
# we then simulate the continious character
cont.trait <- sim.char(trees, 0.2, model = 'BM')
names(cont.trait) <- trees$tip.label # this line somehow makes anc.ML work????
# identifying which branch had a mean cont trait value in the upper and lower quartiles
# we do this by 1st doing an ASR for the continious trait
cont.trait.AC <- anc.ML(trees, cont.trait, model = "BM")
# this will hold all of the branch means in the same order they are given in trees
branch.means <- c()
# branch names is essentially paste(rootward node, tipward node)
branch.names <- c()
# then for each branch we go through and calculate the name and mean
for(j in 1:nrow(trees$edge)){
# we first find the cont trait value at the rootward node
node.o.int <- trees$edge[j,1]
# we have to look in two different places for cont trait values, either in the cont.trait vector
# (if the node is a tip) or in the ASR if it is an interior node
if(node.o.int <= n.taxa){
one <- cont.trait[node.o.int]
}else{
one <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# we do the same for the tipward node
node.o.int <- trees$edge[j,2]
if(node.o.int <= n.taxa){
two <- cont.trait[node.o.int]
}else{
two <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# to find the mean we avg the rootward and the tipward cont trait values
branch.means <- c(branch.means, mean(one, two))
# we create branch names by pasting the rootwward and tipward node labels together
branch.names <- c(branch.names, paste(as.character(trees$edge[j,1]),as.character(trees$edge[j,2])))
}
# we name the branch names for nice bookkeeping
names(branch.means) <- branch.names
rm(branch.names)
# finding upper and lower quartiles
upper <- summary(branch.means)[[4]]
lower <- summary(branch.means)[[2]]
# next we perform the following analysis on this tree for each of the scaling factors
for(s in 1:10){
scale.factor <- s
# we leave the original trees un altered
alt.tree <- trees
# we then manipulate the branch lengths of those branches whose cont trait means are in the upper or lower quartiles
for(j in 1:length(branch.means)){
if(branch.means[j] < lower){alt.tree$edge.length[j] <- alt.tree$edge.length[j] / scale.factor}
if(branch.means[j] > upper){alt.tree$edge.length[j] <- alt.tree$edge.length[j] * scale.factor}
}
# next we simulated a discrete trait on this altered tree
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
count <- 0
rate <- .02
# withTimeout({
while(good.sim == F){
disc.trait <- sim.char(phy = alt.tree,
par = matrix(c(-rate, 0, rate, 0), 2),
model = 'discrete',
root = 1)
if((0.25 * n.taxa) < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (0.75 * n.taxa)){
good.sim <- T
if(message == T){cat(min(disc.trait), max(disc.trait), ' good sim ')}
}
if(message == T && count %% 50 == 0){cat(min(disc.trait),
max(disc.trait),
'    ',
sum(disc.trait == min(disc.trait)),
'      ')}
count <- count + 1
}# }, timeout = 1200, onTimeout = "error")
if(message == T){cat('\n')}
# we now apply the AncCond test to our simulated data and record its result
dat <- cbind(alt.tree$tip.label, cont.trait, disc.trait)
# withTimeout({
rslt <- AncCond(trees = trees,
data = dat,
drop.state = 2,
mat = c(0,0,1,0),
pi = c(1,0),
message = F)# },
# timeout = 1200, onTimeout = "error")
# saving results in arrays
#p.val.array[t,s] <- rslt$pval
p.val.vec[s] <- rslt$pval
if(message == T){cat(' s = ', s)}
}
if(message == T){cat('\n')}
# closting the while loop if all goes well
good.tree <- T
# }, error = function(e){good.tree <- F})
}
if(message == T){
cat('\n')
cat(' t = ', t)
}
p.val.vec
# end <- Sys.time()
}
fig2.data <- p.val.array
save(fig2.data, file = 'AncCondFig2Data.RData')
##### END FIGURE 2 #####
# }
# HPRCAncCondFIG2()
# library(Rmpi)
library(R.utils)
library(phytools)
library(diversitree)
library(geiger)
# library(doSNOW)
# library(foreach)
# cl<-makeCluster(3, type="SOCK")
# on.exit(stopCluster(cl))
# opts <- list(preschedule = FALSE)
# registerDoSNOW(cl)
n.trees <- 100
n.taxa <- 200
message <- T
##### Fig 2 #####
load('AncCondFig2DataPostBlackmon.RData')
data <- cbind(rep(1:10, each = 100),
as.vector(fig2.data))
colnames(data) <- c('Scale.Factor','Pval')
data <- as.data.frame(data)
ggraptR(data)
install.packages("ggraptR")
library(ggraptR)
##### Fig 2 #####
load('AncCondFig2DataPostBlackmon.RData')
data <- cbind(rep(1:10, each = 100),
as.vector(fig2.data))
colnames(data) <- c('Scale.Factor','Pval')
data <- as.data.frame(data)
ggraptR(data)
ggraptR(data)
ggraptR(data)
x <- rep(1:10, each=200)
x <- jitter(x, factor=1.5)
y <- vector()
x <- rep(1:10, each=100)
x <- jitter(x, factor=1.5)
y <- vector()
for(i in 1:10){
y <- c(y, fig2.data[1:100, i])
}
probs <- vector()
for(i in 1:10){
probs[i] <- sum(scaling[1:100, i] <= .05 )
}
plot(x = x, y = y/100, xaxt="n",xlab="", ylab= "", pch=16,cex=.7)
mtext(c("5%","14%","32%","36%","54%","57%","67%","66%","74%","75%"), side=3, at=1:10, cex=.7)
mtext(1:10, side=1, at=1:10, cex=.85)
mtext("Scaling Factor", side=1, line=1)
mtext("p-value", side=2, line=2.2)
sigres <- c()
? as.character
sum(scaling[1:100, i] <= .05 )
sum(fig2.data[1:100, i] <= .05 )
as.character(sum(scaling[1:100, i] < 6))
as.character(sum(fig2.data[1:100, i] < 6))
x <- rep(1:10, each=100)
x <- jitter(x, factor=1.5)
y <- vector()
for(i in 1:10){
y <- c(y, fig2.data[1:100, i])
}
probs <- vector()
for(i in 1:10){
probs[i] <- as.character(sum(fig2.data[1:100, i] < 6))
}
plot(x = x, y = y/100, xaxt="n",xlab="", ylab= "", pch=16,cex=.7)
mtext(probs, side=3, at=1:10, cex=.7)
sum(fig2.data[1:100, i] < 6)
fig2.data[1:100, i]
probs <- vector()
for(i in 1:10){
probs[i] <- as.character(sum(fig2.data[1:100, i] <= .05))
}
plot(x = x, y = y/100, xaxt="n",xlab="", ylab= "", pch=16,cex=.7)
mtext(probs, side=3, at=1:10, cex=.7)
mtext(1:10, side=1, at=1:10, cex=.85)
mtext("Scaling Factor", side=1, line=1)
mtext("p-value", side=2, line=2.2)
max(fig2.data[1:100, i])
max(fig2.data[1:100, 1])
x <- rep(1:10, each=100)
x <- jitter(x, factor=1.5)
y <- vector()
for(i in 1:10){
y <- c(y, fig2.data[1:100, i])
}
probs <- vector()
for(i in 1:10){
probs[i] <- as.character(sum(fig2.data[1:100, i] <= .05))
}
plot(x = x, y = y, xaxt="n",xlab="", ylab= "", pch=16,cex=.7)
mtext(probs, side=3, at=1:10, cex=.7)
mtext(1:10, side=1, at=1:10, cex=.85)
mtext("Scaling Factor", side=1, line=1)
mtext("p-value", side=2, line=2.2)
x <- rep(1:10, each=100)
x <- jitter(x, factor=1.5)
y <- vector()
for(i in 1:10){
y <- c(y, fig2.data[1:100, i])
}
probs <- vector()
for(i in 1:10){
probs[i] <- paste(as.character(sum(fig2.data[1:100, i] <= .05)),'%')
}
plot(x = x, y = y, xaxt="n",xlab="", ylab= "", pch=16,cex=.7)
mtext(probs, side=3, at=1:10, cex=.7)
mtext(1:10, side=1, at=1:10, cex=.85)
mtext("Scaling Factor", side=1, line=1)
mtext("p-value", side=2, line=2.2)
load('AncCondFig2Data.RData')
max(fig2.data[1:100, 10])
sum(fig2.data[1:100, 10] < .05)
load("C:/Users/19726/Desktop/GitHub/Ancestral-Condition-Test/AncCondFig2Data.RData")
x <- rep(1:10, each=100)
x <- jitter(x, factor=1.5)
y <- vector()
for(i in 1:10){
y <- c(y, fig2.data[1:100, i])
}
probs <- vector()
for(i in 1:10){
probs[i] <- paste(as.character(sum(fig2.data[1:100, i] <= .05)),'%')
}
plot(x = x, y = y, xaxt="n",xlab="", ylab= "", pch=16,cex=.7)
mtext(probs, side=3, at=1:10, cex=.7)
mtext(1:10, side=1, at=1:10, cex=.85)
mtext("Scaling Factor", side=1, line=1)
mtext("p-value", side=2, line=2.2)
##### Fig 3 #####
load('AncCondFig3Data.RData')
x <- rep(seq(from=20, to=200, by=20), each=100)
x <- jitter(x, factor=1.5)
y <- vector()
y <- c(y, fig3.data[1:100, i])
probs <- vector()
for(i in 1:10){
y <- c(y, fig3.data[1:100, i])
}
probs <- vector()
x <- rep(seq(from=20, to=200, by=20), each=100)
x <- jitter(x, factor=1.5)
y <- vector()
for(i in 1:10){
y <- c(y, fig3.data[1:100, i])
}
probs <- vector()
for(i in 1:10){
probs[i] <- paste(as.character(sum(fig3.data[1:100, i] <= .05)),'%')
}
plot(x = x, y = y, xlab="", ylab= "", xaxt="n",
pch=16,cex=.7, xlim=c(10, 210))
mtext(probs,
side=3, at=seq(from=20, to=200, by=20), cex=.7)
mtext(c(20,40,60,80,100,120,140,160,180,200), side=1,
at=c(20,40,60,80,100,120,140,160,180,200), cex=.85)
mtext("Taxa", side=1, line=1)
mtext("p-value", side=2, line=2.2)
library(ggraptR)
##### Fig 2 #####
load('AncCondFig2DataPostBlackmon.RData')
# data <- cbind(rep(1:10, each = 100),
#               as.vector(fig2.data))
# colnames(data) <- c('Scale.Factor','Pval')
#
# data <- as.data.frame(data)
# ggraptR(data)
x <- rep(1:10, each=100)
x <- jitter(x, factor=1.5)
y <- vector()
for(i in 1:10){
y <- c(y, fig2.data[1:100, i])
}
probs <- vector()
for(i in 1:10){
probs[i] <- paste(as.character(sum(fig2.data[1:100, i] <= .05)),'%')
}
plot(x = x, y = y, xaxt="n",xlab="", ylab= "", pch=16,cex=.7)
mtext(probs, side=3, at=1:10, cex=.7)
mtext(1:10, side=1, at=1:10, cex=.85)
mtext("Scaling Factor", side=1, line=1)
mtext("p-value", side=2, line=2.2)
x <- rep(seq(from=20, to=200, by=20), each=100)
x <- jitter(x, factor=1.5)
y <- vector()
for(i in 1:10){
y <- c(y, fig3.data[1:100, i])
}
probs <- vector()
for(i in 1:10){
probs[i] <- paste(as.character(sum(fig3.data[1:100, i] <= .05)),'%')
}
plot(x = x, y = y, xlab="", ylab= "", xaxt="n",
pch=16,cex=.7, xlim=c(10, 210))
mtext(probs,
side=3, at=seq(from=20, to=200, by=20), cex=.7)
mtext(c(20,40,60,80,100,120,140,160,180,200), side=1,
at=c(20,40,60,80,100,120,140,160,180,200), cex=.85)
mtext("Taxa", side=1, line=1)
mtext("p-value", side=2, line=2.2)
install.packages("diversitree")
install.packages("geiger")
# install.packages(c("Rmpi", 'doMPI'))
# library(doMPI)
# library(Rmpi)
library(R.utils)
library(phytools)
library(diversitree)
library(geiger)
library(doSNOW)
library(foreach)
cl<-makeCluster(3, type="SOCK")
on.exit(stopCluster(cl))
opts <- list(preschedule = FALSE)
registerDoSNOW(cl)
n.trees <- 100
n.taxa <- 200
message <- T
source('AncCond.R', local = TRUE)
# ~50 min
# start <- Sys.time()
# cnt <- 0
# while(T == T){
p.val.vec <- c()
# good.tree <- F
#  cnt <- cnt + 1
#  cat(cnt, '\n\n')
#  while(good.tree == F){
# some trees take a real long time for simulating discrete traits due to incredibly short branch lengths where a transition
#   must occur. To get around this we added a timeout and trycatch. In the event of a tree that is taking an unacceptable time,
#   we begin back here by resimulating a tree
#tryCatch({
# We begin with a single tree and test it at every scaling factor then move to the next tree
# first the tree
trees <- trees(pars = c(3,1),
type = "bd",
n = 1,
max.taxa = n.taxa,
include.extinct = F)[[1]]
trees$edge.length <- trees$edge.length / max(branching.times(trees))
# install.packages(c("Rmpi", 'doMPI'))
# library(doMPI)
# library(Rmpi)
library(R.utils)
library(phytools)
library(diversitree)
library(geiger)
library(doSNOW)
install.packages("phytools")
install.packages("diversitree")
install.packages("geiger")
install.packages("phytools")
# install.packages(c("Rmpi", 'doMPI'))
# library(doMPI)
# library(Rmpi)
library(R.utils)
library(phytools)
library(diversitree)
library(geiger)
install.packages("diversitree")
install.packages("phytools")
install.packages("diversitree")
install.packages("geiger")
# install.packages(c("Rmpi", 'doMPI'))
# library(doMPI)
# library(Rmpi)
library(R.utils)
library(phytools)
library(diversitree)
library(geiger)
install.packages("geiger")
install.packages("geiger")
install.packages("geiger")
library(geiger)
install.packages("diversitree")
library(diversitree)
h
library(doSNOW)
library(foreach)
cl<-makeCluster(3, type="SOCK")
on.exit(stopCluster(cl))
opts <- list(preschedule = FALSE)
registerDoSNOW(cl)
n.trees <- 100
n.taxa <- 200
message <- T
source('AncCond.R', local = TRUE)
##### Making fig2 ######
# good.tree <- F
#  cnt <- cnt + 1
#  cat(cnt, '\n\n')
#  while(good.tree == F){
# some trees take a real long time for simulating discrete traits due to incredibly short branch lengths where a transition
#   must occur. To get around this we added a timeout and trycatch. In the event of a tree that is taking an unacceptable time,
#   we begin back here by resimulating a tree
#tryCatch({
# We begin with a single tree and test it at every scaling factor then move to the next tree
# first the tree
trees <- trees(pars = c(3,1),
type = "bd",
n = 1,
max.taxa = n.taxa,
include.extinct = F)[[1]]
install.packages("diversitree")
install.packages("diversitree")
?remove.packages
remove.packages('diversitree', 'geiger')
