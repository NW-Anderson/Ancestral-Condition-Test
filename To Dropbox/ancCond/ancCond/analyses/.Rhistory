nsim = 12,
iter = 101,
message = T,
make.plot = F)
source('~/GitHub/Ancestral-Condition-Test/To Dropbox/ancCond/ancCond/analyses/internal.functions.R')
res <- AncCond(tree,
dat,
drop.state=NULL,
mat=c(0,2,1,0),
pi="estimated",
n.tails = 1,
nsim = 12,
iter = 101,
message = T,
make.plot = F)
source('~/GitHub/Ancestral-Condition-Test/To Dropbox/ancCond/ancCond/analyses/internal.functions.R')
source('~/GitHub/Ancestral-Condition-Test/To Dropbox/ancCond/ancCond/analyses/internal.functions.R')
plot(res)
install.packages('lava')
library(lava)
plot(res)
source('~/GitHub/Ancestral-Condition-Test/To Dropbox/ancCond/ancCond/analyses/internal.functions.R')
plot(res)
source('~/GitHub/Ancestral-Condition-Test/To Dropbox/ancCond/ancCond/analyses/internal.functions.R')
##### Bidirectional #####
library(phytools)
library(geiger)
library(diversitree)
ntaxa <- 200
scale.factor <- 2
rate <- .6
tree <- trees(pars = c(3,1),
type = "bd",
n = 1,
max.taxa = ntaxa,
include.extinct = F)[[1]]
tree$edge.length <- tree$edge.length / max(branching.times(tree))
# we then simulate the continious character
cont.trait <- sim.char(tree, 0.2, model = 'BM')[,,1]
# identifying which branch had a mean cont trait value in the upper and lower quartiles
# we do this by 1st doing an ASR for the continious trait
cont.trait.AC <- anc.ML(tree, cont.trait, model = "BM")
# this will hold all of the branch means in the same order they are given in tree
branch.means <- c()
# branch names is essentially paste(rootward node, tipward node)
branch.names <- c()
# then for each branch we go through and calculate the name and mean
for(j in 1:nrow(tree$edge)){
# we first find the cont trait value at the rootward node
node.o.int <- tree$edge[j,1]
# we have to look in two different places for cont trait values, either in the cont.trait vector
# (if the node is a tip) or in the ASR if it is an interior node
if(node.o.int <= ntaxa){
one <- cont.trait[node.o.int]
}else{
one <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# we do the same for the tipward node
node.o.int <- tree$edge[j,2]
if(node.o.int <= ntaxa){
two <- cont.trait[node.o.int]
}else{
two <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# to find the mean we avg the rootward and the tipward cont trait values
branch.means <- c(branch.means, mean(one, two))
# we create branch names by pasting the rootwward and tipward node labels together
branch.names <- c(branch.names, paste(as.character(tree$edge[j,1]),as.character(tree$edge[j,2])))
}
# we name the branch names for nice bookkeeping
names(branch.means) <- branch.names
# finding upper and lower quartiles
upper <- summary(branch.means)[[5]]
lower <- summary(branch.means)[[2]]
# next we perform the following analysis on this tree for each of the scaling factors
# we leave the original tree un altered
alt.tree <- tree
# we then manipulate the branch lengths of those branches whose cont trait means are in the upper or lower quartiles
for(j in 1:length(branch.means)){
if(branch.means[j] < lower){alt.tree$edge.length[j] <- alt.tree$edge.length[j] / scale.factor}
if(branch.means[j] > upper){alt.tree$edge.length[j] <- alt.tree$edge.length[j] * scale.factor}
}
# next we simulated a discrete trait on this altered tree
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
while(good.sim == F){
disc.trait <- sim.char(phy = alt.tree,
par = matrix(c(-rate, rate, rate, -rate), 2),
model = 'discrete',
root = sample(c(1,2),1))
if((0.05 * ntaxa) < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (.95 * ntaxa)){
good.sim <- T
}
}
# we now apply the AncCond test to our simulated data and record its result
data <- data.frame(alt.tree$tip.label, cont.trait, disc.trait)
nsim <- 3
iter <- 100
drop.state <- NULL
mat <- c(0,2,1,0)
pi <- 'estimated'
n.tails <- 2
message <- T
make.plot <- T
rm(list=ls()[-c(24,6,8,14,21,16,18,10,15,14,13)])
# This will generate warnings and stop if we violate
# any basic assumptions on incoming data
InputTesting(tree,
data,
drop.state,
mat,
pi,
n.tails,
nsim,
iter)
source('internal.functions.R')
# This will generate warnings and stop if we violate
# any basic assumptions on incoming data
InputTesting(tree,
data,
drop.state,
mat,
pi,
n.tails,
nsim,
iter)
# should we unit length the tree???
# prepare data format
unpackeddata <- UnpackData(data, drop.state)
dt.vec <- unpackeddata[[1]]
ct.vec <- unpackeddata[[2]]
rm(unpackeddata)
# ASR for the continuous trait
anc.states.cont.trait <- anc.ML(tree, ct.vec, model = "BM")
# Stochastic map for discrete trait using stochastic mappings to nail
# down specific transition points
if(message) cat('Simulatig stochasstic mappings:','\014')
anc.state.dt <- make.simmap(tree, dt.vec,
model = matrix(mat,2),
nsim = nsim,
pi = pi,
Q = 'mcmc',
message = message)
# processing our stoch maps to extract the ancestral condition and
# construct the null
observed.anc.cond <- list()
null.anc.cond <- list()
j=1
if(message){
cat('\014')
cat('Analyzing map: ',j,' of ', nsim)
}
anc.state.dt[[j]]
current.map = anc.state.dt[[j]]
View(current.map)
#### Parse simmap to get producing nodes ####
# the mapped edge object has time spent in a state in
# two columns so only branches with a change have an entry
# in both columns
#######
# gets branches with transitions
ss_nodes <- current.map$mapped.edge[, 1] > 0 &
current.map$mapped.edge[, 2] > 0
# this returns the node pairs describing a branch with transitions
wanted_branches <- ss_nodes[ss_nodes == T]
wanted_nodes <- names(wanted_branches)
# for the general model we partition the producing nodes for 1->2 and 1<-2 transitions
producing.nodes12 <- c()
producing.nodes21 <-c()
trans.maps <- current.map$maps[ss_nodes == T]
# now we take the rootward node of each branch and get rid of duplicates
wanted_nodes <- gsub(",.*", "", wanted_nodes)
##### Just realized we can do this with describe.simmap :(
##### But i dont want to change it, it would require match function
for(i in 1:length(wanted_nodes)){
if(names(trans.maps[[i]])[1] == '1'){
producing.nodes12 <- c(producing.nodes12, wanted_nodes[i])
}else if(names(trans.maps[[i]])[1] == '2'){
producing.nodes21 <- c(producing.nodes21, wanted_nodes[i])
}
}
producing.nodes12 <- unique(producing.nodes12)
producing.nodes21 <- unique(producing.nodes21)
list('12' = anc.states.cont.trait$ace[names(anc.states.cont.trait$ace) %in%
producing.nodes12],
'21' = anc.states.cont.trait$ace[names(anc.states.cont.trait$ace) %in%
producing.nodes21])
for(j in 1:nsim){
if(message){
cat('\014')
cat('Analyzing map: ',j,' of ', nsim)
}
observed.anc.cond[[j]] <- exctractAncestral(current.map = anc.state.dt[[j]],
anc.states.cont.trait)
# creating the null
current.map <- anc.state.dt[[j]]
null.anc.cond[[j]] <- CreateNull(tree = tree,
iter = iter,
current.map = current.map,
anc.states.cont.trait = anc.states.cont.trait)
}
observed.anc.cond
obs.dist <- ProcessObserved(observed.anc.cond)
null.dist <- ProcessNull(null.anc.cond, iter)
obs.dist <- ProcessObserved(observed.anc.cond)
obs.dist
#### Parse simmap to get producing nodes ####
# the mapped edge object has time spent in a state in
# two columns so only branches with a change have an entry
# in both columns
#######
# gets branches with transitions
ss_nodes <- current.map$mapped.edge[, 1] > 0 &
current.map$mapped.edge[, 2] > 0
# this returns the node pairs describing a branch with transitions
wanted_branches <- ss_nodes[ss_nodes == T]
wanted_nodes <- names(wanted_branches)
# for the general model we partition the producing nodes for 1->2 and 1<-2 transitions
producing.nodes12 <- c()
producing.nodes21 <-c()
trans.maps <- current.map$maps[ss_nodes == T]
trans.maps
# now we take the rootward node of each branch and get rid of duplicates
wanted_nodes <- gsub(",.*", "", wanted_nodes)
##### Just realized we can do this with describe.simmap :(
##### But i dont want to change it, it would require match function
for(i in 1:length(wanted_nodes)){
if(names(trans.maps[[i]])[1] == '1'){
producing.nodes12 <- c(producing.nodes12, wanted_nodes[i])
}else if(names(trans.maps[[i]])[1] == '2'){
producing.nodes21 <- c(producing.nodes21, wanted_nodes[i])
}
}
producing.nodes12 <- unique(producing.nodes12)
producing.nodes21 <- unique(producing.nodes21)
plot(current.map)
nodelabels()
# for the general model we partition the producing nodes for 1->2 and 1<-2 transitions
producing.nodes12 <- c()
producing.nodes21 <-c()
trans.maps <- current.map$maps[ss_nodes == T]
# now we take the rootward node of each branch and get rid of duplicates
wanted_nodes <- gsub(",.*", "", wanted_nodes)
##### Just realized we can do this with describe.simmap :(
##### But i dont want to change it, it would require match function
for(i in 1:length(wanted_nodes)){
if(names(trans.maps[[i]])[1] == '1'){
producing.nodes12 <- c(producing.nodes12, wanted_nodes[i])
}else if(names(trans.maps[[i]])[1] == '2'){
producing.nodes21 <- c(producing.nodes21, wanted_nodes[i])
}
}
producing.nodes21
source('~/GitHub/Ancestral-Condition-Test/To Dropbox/ancCond/ancCond/analyses/internal.functions.R')
source('~/GitHub/Ancestral-Condition-Test/To Dropbox/ancCond/ancCond/analyses/internal.functions.R')
plot(density(results$null$`12`),
main = '1 -> 2',
xlim= c(min(c(results$null$`12`,
results$observed[1])),
max(c(results$null$`12`,
results$observed[1]))),
xlab = 'Ancestral Condition',
ylab = 'Frequency')
plot(density(results$null$`12`),
main = '1 -> 2'
)
obs.dist <- ProcessObserved(observed.anc.cond)
null.dist <- ProcessNull(null.anc.cond, iter)
names(results) <- c("observed","null")
results <- list(obs.dist, null.dist)
pvals <- CalcPVal(results, n.tails)
results <- list(obs.dist, null.dist)
names(results) <- c("observed","null")
pvals <- CalcPVal(results, n.tails)
results <- list(obs.dist, null.dist,pvals)
names(results) <- c("observed","null",'pvals')
class(results) <- "AncCond"
if(message) summary(results)
plot(results)
rm.dw()
plot(results)
if(!is.na(results$pvals[1])){
plot(density(results$null$`12`),
main = '1 -> 2',
xlim= c(min(c(results$null$`12`,
results$observed[1])),
max(c(results$null$`12`,
results$observed[1]))),
xlab = 'Ancestral Condition',
ylab = 'Frequency')
abline(v=results$observed[1], col = 'red')
legend(x = 'topright', legend = c('Observed','Null'), col = c('red', 'black'), lwd = 2)
if(!is.na(results$pvals[2])) wait()
}
main = '2 -> 1',
xlim= c(min(c(results$null$`21`,
results$observed[2])),
max(c(results$null$`21`,
results$observed[2]))),
xlab = 'Ancestral Condition',
ylab = 'Frequency')
abline(v=results$observed[2], col = 'red')
legend(x = 'topright', legend = c('Observed','Null'), col = c('red', 'black'), lwd = 2)
}
}
plot(density(results$null$`12`),
main = '1 -> 2',
xlim= c(min(c(results$null$`12`,
results$observed[1])),
max(c(results$null$`12`,
results$observed[1]))),
xlab = 'Ancestral Condition',
ylab = 'Frequency')
plot(density(results$null$`12`),
main = c('1 -> 2'),
xlim = c(0,1))
plot(density(results$null$`12`),
main = c('1 -> 2'),
xlim = c(0,1),
ylab = 'Frequency'
xlab = 'Ancestral Condition')
plot(density(results$null$`12`),
main = c('1 -> 2'),
xlim = c(0,1),
ylab = 'Frequency'm
xlab = 'Ancestral Condition')
plot(density(results$null$`12`),
main = c('1 -> 2'),
xlim = c(0,1),
ylab = 'Frequency',
xlab = 'Ancestral Condition')
plot(density(results$null$`12`,
main = c('1 -> 2'),
xlim = c(0,1),
ylab = 'Frequency',
xlab = 'Ancestral Condition')
plot(density(results$null$`12`,
main = '1 -> 2',
xlim= c(min(c(results$null$`12`,
results$observed[1])),
max(c(results$null$`12`,
results$observed[1]))),
xlab = 'Ancestral Condition',
ylab = 'Frequency')
abline(v=results$observed[1], col = 'red')
legend(x = 'topright', legend = c('Observed','Null'), col = c('red', 'black'), lwd = 2)
if(!is.na(results$pvals[2])) wait()
plot(density(results$null$`21`),
main = '1 -> 2',
xlim= c(min(c(results$null$`21`,
results$observed[2])),
max(c(results$null$`21`,
results$observed[2]))),
xlab = 'Ancestral Condition',
ylab = 'Frequency')
abline(v=results$observed[2], col = 'red')
legend(x = 'topright', legend = c('Observed','Null'), col = c('red', 'black'), lwd = 2)
}
}
CalcPVal <- function(results, n.tails){
bigger12 <- sum(results$null$`12` >= results$observed[1]) / length(results$null$`12`)
smaller12 <- sum(results$null$`12` < results$observed[1]) / length(results$null$`12`)
if(sum(c(is.na(bigger12),is.na(smaller12))) == 0){
if (bigger12 <= smaller12){pval12 <- bigger12}
if (smaller12 < bigger12){pval12 <- smaller12}
if (n.tails == 2){pval12 <- 2 * pval12}
}else{pval12 <- NA}
bigger21 <- sum(results$null$`21` >= results$observed[2]) / length(results$null$`21`)
smaller21 <- sum(results$null$`21` < results$observed[2]) / length(results$null$`21`)
if(sum(c(is.na(bigger21),is.na(smaller21))) == 0){
if (bigger21 <= smaller21){pval21 <- bigger21}
if (smaller21 < bigger21){pval21 <- smaller21}
if (n.tails == 2){pval21 <- 2 * pval21}
}else{pval21 <- NA}
res <- c(pval12, pval21)
names(res) <- c('12','21')
return(res)
}
summary.AncCond <- function(results){
## print results to terminal
cat('\014')
cat(paste(
"Mean value for the continuous trait at 1 - > 2 transitions:",
round(results$observed[1], digits = 4),
"\n"
))
cat(paste(
"Mean value for the continuous trait at 2 - > 1 transitions:",
round(results$observed[2], digits = 4),
"\n\n"
))
# cat(paste("Number of producing nodes 1->2:", round(mean(number.of.trans12),
#                                                    digits = 4), "\n"))
# cat(paste("Number of producing nodes 2->1:", round(mean(number.of.trans21),
#                                                    digits = 4), "\n"))
cat(paste("Mean of null dist 1->2:", round(mean(results$null$`12`),
digits = 4), "\n"))
cat(paste("Mean of null dist 2->1:", round(mean(results$null$`21`),
digits = 4), "\n\n"))
cat(paste("SD of null dist 1->2:", round(sd(results$null$`12`), digits = 4), "\n"))
cat(paste("SD of null dist 2->1:", round(sd(results$null$`21`), digits = 4), "\n\n"))
cat(paste("pvalue 1->2:", round(results$pvals[1], digits = 4), "\n"))
cat(paste("pvalue 2->1:", round(results$pvals[2], digits = 4), "\n\n\n"))
if(is.na(results$pvals[1])){
cat('NA and NaN values are produced when no transitions of a type have occured. \n\n')
}
if(is.na(results$pvals[2])){
cat('NA and NaN values are produced when no transitions of a type have occured. \n\n')
}
}
plot(density(results$null$`12`,
main = c('1 -> 2'),
xlim = c(0,1),
ylab = 'Frequency',
xlab = 'Ancestral Condition')
plot(density(results$null$`12`,
main = '1 -> 2',
xlim= c(min(c(results$null$`12`,
results$observed[1])),
max(c(results$null$`12`,
results$observed[1]))),
xlab = 'Ancestral Condition',
ylab = 'Frequency')
abline(v=results$observed[1], col = 'red')
legend(x = 'topright', legend = c('Observed','Null'), col = c('red', 'black'), lwd = 2)
if(!is.na(results$pvals[2])) wait()
plot(density(results$null$`21`),
main = '1 -> 2',
xlim= c(min(c(results$null$`21`,
results$observed[2])),
max(c(results$null$`21`,
results$observed[2]))),
xlab = 'Ancestral Condition',
ylab = 'Frequency')
abline(v=results$observed[2], col = 'red')
legend(x = 'topright', legend = c('Observed','Null'), col = c('red', 'black'), lwd = 2)
}
}
CalcPVal <- function(results, n.tails){
bigger12 <- sum(results$null$`12` >= results$observed[1]) / length(results$null$`12`)
smaller12 <- sum(results$null$`12` < results$observed[1]) / length(results$null$`12`)
if(sum(c(is.na(bigger12),is.na(smaller12))) == 0){
if (bigger12 <= smaller12){pval12 <- bigger12}
if (smaller12 < bigger12){pval12 <- smaller12}
if (n.tails == 2){pval12 <- 2 * pval12}
}else{pval12 <- NA}
bigger21 <- sum(results$null$`21` >= results$observed[2]) / length(results$null$`21`)
smaller21 <- sum(results$null$`21` < results$observed[2]) / length(results$null$`21`)
if(sum(c(is.na(bigger21),is.na(smaller21))) == 0){
if (bigger21 <= smaller21){pval21 <- bigger21}
if (smaller21 < bigger21){pval21 <- smaller21}
if (n.tails == 2){pval21 <- 2 * pval21}
}else{pval21 <- NA}
res <- c(pval12, pval21)
names(res) <- c('12','21')
return(res)
}
summary.AncCond <- function(results){
## print results to terminal
cat('\014')
cat(paste(
"Mean value for the continuous trait at 1 - > 2 transitions:",
round(results$observed[1], digits = 4),
"\n"
))
cat(paste(
"Mean value for the continuous trait at 2 - > 1 transitions:",
round(results$observed[2], digits = 4),
"\n\n"
))
# cat(paste("Number of producing nodes 1->2:", round(mean(number.of.trans12),
#                                                    digits = 4), "\n"))
# cat(paste("Number of producing nodes 2->1:", round(mean(number.of.trans21),
#                                                    digits = 4), "\n"))
cat(paste("Mean of null dist 1->2:", round(mean(results$null$`12`),
digits = 4), "\n"))
cat(paste("Mean of null dist 2->1:", round(mean(results$null$`21`),
digits = 4), "\n\n"))
cat(paste("SD of null dist 1->2:", round(sd(results$null$`12`), digits = 4), "\n"))
cat(paste("SD of null dist 2->1:", round(sd(results$null$`21`), digits = 4), "\n\n"))
cat(paste("pvalue 1->2:", round(results$pvals[1], digits = 4), "\n"))
cat(paste("pvalue 2->1:", round(results$pvals[2], digits = 4), "\n\n\n"))
if(is.na(results$pvals[1])){
cat('NA and NaN values are produced when no transitions of a type have occured. \n\n')
}
if(is.na(results$pvals[2])){
cat('NA and NaN values are produced when no transitions of a type have occured. \n\n')
}
}
plot(density(results$null$`12`),
main = c('1 -> 2'),
xlim = c(0,1),
ylab = 'Frequency',
xlab = 'Ancestral Condition')
abline(v=results$observed[1], col = 'red')
legend(x = 'topright', legend = c('Observed','Null'), col = c('red', 'black'), lwd = 2)
?plot
source('~/GitHub/Ancestral-Condition-Test/To Dropbox/ancCond/ancCond/analyses/internal.functions.R')
results
results$nul;
results$null
results$null$`12`
obs.dist <- ProcessObserved(observed.anc.cond)
null.dist <- ProcessNull(null.anc.cond, iter)
results <- list(obs.dist, null.dist)
names(results) <- c("observed","null")
pvals <- CalcPVal(results, n.tails)
results <- list(obs.dist, null.dist,pvals)
names(results) <- c("observed","null",'pvals')
class(results) <- "AncCond"
source('~/GitHub/Ancestral-Condition-Test/To Dropbox/ancCond/ancCond/analyses/internal.functions.R')
